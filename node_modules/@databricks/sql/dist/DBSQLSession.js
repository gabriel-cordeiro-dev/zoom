"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const uuid_1 = require("uuid");
const Types_1 = require("./hive/Types");
const DBSQLOperation_1 = __importDefault(require("./DBSQLOperation"));
const Status_1 = __importDefault(require("./dto/Status"));
const InfoValue_1 = __importDefault(require("./dto/InfoValue"));
const utils_1 = require("./utils");
const IDBSQLLogger_1 = require("./contracts/IDBSQLLogger");
const globalConfig_1 = __importDefault(require("./globalConfig"));
const defaultMaxRows = 100000;
function getDirectResultsOptions(maxRows = defaultMaxRows) {
    if (maxRows === null) {
        return {};
    }
    return {
        getDirectResults: {
            maxRows: new Types_1.Int64(maxRows),
        },
    };
}
function getArrowOptions() {
    const { arrowEnabled = true, useArrowNativeTypes = true } = globalConfig_1.default;
    if (!arrowEnabled) {
        return {
            canReadArrowResult: false,
        };
    }
    return {
        canReadArrowResult: true,
        useArrowNativeTypes: {
            timestampAsArrow: useArrowNativeTypes,
            decimalAsArrow: useArrowNativeTypes,
            complexTypesAsArrow: useArrowNativeTypes,
            // TODO: currently unsupported by `apache-arrow` (see https://github.com/streamlit/streamlit/issues/4489)
            intervalTypesAsArrow: false,
        },
    };
}
class DBSQLSession {
    constructor(driver, sessionHandle, logger) {
        this.driver = driver;
        this.sessionHandle = sessionHandle;
        this.logger = logger;
        this.logger.log(IDBSQLLogger_1.LogLevel.debug, `Session created with id: ${this.getId()}`);
    }
    getId() {
        var _a, _b;
        return (0, uuid_1.stringify)(((_b = (_a = this.sessionHandle) === null || _a === void 0 ? void 0 : _a.sessionId) === null || _b === void 0 ? void 0 : _b.guid) || (0, uuid_1.parse)(uuid_1.NIL));
    }
    /**
     * Fetches info
     * @public
     * @param infoType - One of the values TCLIService_types.TGetInfoType
     * @returns Value corresponding to info type requested
     * @example
     * const response = await session.getInfo(thrift.TCLIService_types.TGetInfoType.CLI_DBMS_VER);
     */
    getInfo(infoType) {
        return __awaiter(this, void 0, void 0, function* () {
            const response = yield this.driver.getInfo({
                sessionHandle: this.sessionHandle,
                infoType,
            });
            Status_1.default.assert(response.status);
            return new InfoValue_1.default(response.infoValue);
        });
    }
    /**
     * Executes statement
     * @public
     * @param statement - SQL statement to be executed
     * @param options - maxRows field is used to specify Direct Results
     * @returns DBSQLOperation
     * @example
     * const operation = await session.executeStatement(query, { runAsync: true });
     */
    executeStatement(statement, options = {}) {
        return __awaiter(this, void 0, void 0, function* () {
            const response = yield this.driver.executeStatement(Object.assign(Object.assign({ sessionHandle: this.sessionHandle, statement, queryTimeout: options.queryTimeout, runAsync: options.runAsync || false }, getDirectResultsOptions(options.maxRows)), getArrowOptions()));
            return this.createOperation(response);
        });
    }
    /**
     * Information about supported data types
     * @public
     * @param request
     * @returns DBSQLOperation
     */
    getTypeInfo(request = {}) {
        return __awaiter(this, void 0, void 0, function* () {
            const response = yield this.driver.getTypeInfo(Object.assign({ sessionHandle: this.sessionHandle, runAsync: request.runAsync || false }, getDirectResultsOptions(request.maxRows)));
            return this.createOperation(response);
        });
    }
    /**
     * Get list of catalogs
     * @public
     * @param request
     * @returns DBSQLOperation
     */
    getCatalogs(request = {}) {
        return __awaiter(this, void 0, void 0, function* () {
            const response = yield this.driver.getCatalogs(Object.assign({ sessionHandle: this.sessionHandle, runAsync: request.runAsync || false }, getDirectResultsOptions(request.maxRows)));
            return this.createOperation(response);
        });
    }
    /**
     * Get list of schemas
     * @public
     * @param request
     * @returns DBSQLOperation
     */
    getSchemas(request = {}) {
        return __awaiter(this, void 0, void 0, function* () {
            const response = yield this.driver.getSchemas(Object.assign({ sessionHandle: this.sessionHandle, catalogName: request.catalogName, schemaName: request.schemaName, runAsync: request.runAsync || false }, getDirectResultsOptions(request.maxRows)));
            return this.createOperation(response);
        });
    }
    /**
     * Get list of tables
     * @public
     * @param request
     * @returns DBSQLOperation
     */
    getTables(request = {}) {
        return __awaiter(this, void 0, void 0, function* () {
            const response = yield this.driver.getTables(Object.assign({ sessionHandle: this.sessionHandle, catalogName: request.catalogName, schemaName: request.schemaName, tableName: request.tableName, tableTypes: request.tableTypes, runAsync: request.runAsync || false }, getDirectResultsOptions(request.maxRows)));
            return this.createOperation(response);
        });
    }
    /**
     * Get list of supported table types
     * @public
     * @param request
     * @returns DBSQLOperation
     */
    getTableTypes(request = {}) {
        return __awaiter(this, void 0, void 0, function* () {
            const response = yield this.driver.getTableTypes(Object.assign({ sessionHandle: this.sessionHandle, runAsync: request.runAsync || false }, getDirectResultsOptions(request.maxRows)));
            return this.createOperation(response);
        });
    }
    /**
     * Get full information about columns of the table
     * @public
     * @param request
     * @returns DBSQLOperation
     */
    getColumns(request = {}) {
        return __awaiter(this, void 0, void 0, function* () {
            const response = yield this.driver.getColumns(Object.assign({ sessionHandle: this.sessionHandle, catalogName: request.catalogName, schemaName: request.schemaName, tableName: request.tableName, columnName: request.columnName, runAsync: request.runAsync || false }, getDirectResultsOptions(request.maxRows)));
            return this.createOperation(response);
        });
    }
    /**
     * Get information about function
     * @public
     * @param request
     * @returns DBSQLOperation
     */
    getFunctions(request) {
        return __awaiter(this, void 0, void 0, function* () {
            const response = yield this.driver.getFunctions(Object.assign({ sessionHandle: this.sessionHandle, catalogName: request.catalogName, schemaName: request.schemaName, functionName: request.functionName, runAsync: request.runAsync || false }, getDirectResultsOptions(request.maxRows)));
            return this.createOperation(response);
        });
    }
    getPrimaryKeys(request) {
        return __awaiter(this, void 0, void 0, function* () {
            const response = yield this.driver.getPrimaryKeys(Object.assign({ sessionHandle: this.sessionHandle, catalogName: request.catalogName, schemaName: request.schemaName, tableName: request.tableName, runAsync: request.runAsync || false }, getDirectResultsOptions(request.maxRows)));
            return this.createOperation(response);
        });
    }
    /**
     * Request information about foreign keys between two tables
     * @public
     * @param request
     * @returns DBSQLOperation
     */
    getCrossReference(request) {
        return __awaiter(this, void 0, void 0, function* () {
            const response = yield this.driver.getCrossReference(Object.assign({ sessionHandle: this.sessionHandle, parentCatalogName: request.parentCatalogName, parentSchemaName: request.parentSchemaName, parentTableName: request.parentTableName, foreignCatalogName: request.foreignCatalogName, foreignSchemaName: request.foreignSchemaName, foreignTableName: request.foreignTableName, runAsync: request.runAsync || false }, getDirectResultsOptions(request.maxRows)));
            return this.createOperation(response);
        });
    }
    /**
     * Closes the session
     * @public
     * @returns Operation status
     */
    close() {
        return __awaiter(this, void 0, void 0, function* () {
            const response = yield this.driver.closeSession({
                sessionHandle: this.sessionHandle,
            });
            this.logger.log(IDBSQLLogger_1.LogLevel.debug, `Session closed with id: ${this.getId()}`);
            Status_1.default.assert(response.status);
            return new Status_1.default(response.status);
        });
    }
    createOperation(response) {
        Status_1.default.assert(response.status);
        const handle = (0, utils_1.definedOrError)(response.operationHandle);
        return new DBSQLOperation_1.default(this.driver, handle, this.logger, response.directResults);
    }
}
exports.default = DBSQLSession;
//# sourceMappingURL=DBSQLSession.js.map